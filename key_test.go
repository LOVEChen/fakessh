package main

import (
	"crypto/ed25519"
	"reflect"
	"testing"
)

//-----BEGIN PRIVATE KEY-----
//MC4CAQAwBQYDK2VwBCIEIC0/5gf05fFCPN5dF+9B6jEp4arYqOoKavt00ngyVpiS
//-----END PRIVATE KEY-----\n
var priKey = ed25519.PrivateKey{
	0x2d, 0x3f, 0xe6, 0x07, 0xf4, 0xe5, 0xf1, 0x42, 0x3c, 0xde, 0x5d, 0x17, 0xef, 0x41, 0xea, 0x31,
	0x29, 0xe1, 0xaa, 0xd8, 0xa8, 0xea, 0x0a, 0x6a, 0xfb, 0x74, 0xd2, 0x78, 0x32, 0x56, 0x98, 0x92,
	0xf0, 0x56, 0x8c, 0x5e, 0xf7, 0xc3, 0xa3, 0x15, 0xfd, 0x86, 0x79, 0xa8, 0xdc, 0x46, 0x86, 0x6e,
	0x5d, 0x46, 0xe5, 0xaf, 0x88, 0x44, 0x01, 0xdf, 0xb0, 0x85, 0x58, 0x02, 0x69, 0xdd, 0xc3, 0xfc,
}
var marshaled = []byte{
	0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
	0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x43, 0x34, 0x43,
	0x41, 0x51, 0x41, 0x77, 0x42, 0x51, 0x59, 0x44, 0x4b, 0x32, 0x56, 0x77, 0x42, 0x43, 0x49, 0x45,
	0x49, 0x43, 0x30, 0x2f, 0x35, 0x67, 0x66, 0x30, 0x35, 0x66, 0x46, 0x43, 0x50, 0x4e, 0x35, 0x64,
	0x46, 0x2b, 0x39, 0x42, 0x36, 0x6a, 0x45, 0x70, 0x34, 0x61, 0x72, 0x59, 0x71, 0x4f, 0x6f, 0x4b,
	0x61, 0x76, 0x74, 0x30, 0x30, 0x6e, 0x67, 0x79, 0x56, 0x70, 0x69, 0x53, 0x0a, 0x2d, 0x2d, 0x2d,
	0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45,
	0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
}
var base64Key = string(marshaled)

func Test_marshalPriKey(t *testing.T) {

	tests := []struct {
		name    string
		key     ed25519.PrivateKey
		want    []byte
		wantErr bool
	}{
		{
			"test_marshal_private_key",
			priKey,
			marshaled,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := marshalPriKey(tt.key)
			if (err != nil) != tt.wantErr {
				t.Errorf("marshalKey() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("marshalKey() = %v, want %v", got, tt.want)
			}
		})
	}
}
